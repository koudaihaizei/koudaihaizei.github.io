<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JokerSite</title>
    <link>https://koudaihaizei.github.io/</link>
    <description>Recent content on JokerSite</description>
    <image>
      <url>https://koudaihaizei.github.io/images/site/lien</url>
      <link>https://koudaihaizei.github.io/images/site/lien</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 22 May 2022 21:25:28 +0800</lastBuildDate><atom:link href="https://koudaihaizei.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode3</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode3/</link>
      <pubDate>Sun, 22 May 2022 21:25:28 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode3/</guid>
      <description>3. 无重复字符的最长子串  给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: s = &amp;ldquo;abcabcbb&amp;rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。 示例 2:
输入: s = &amp;ldquo;bbbbb&amp;rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;ldquo;b&amp;rdquo;，所以其长度为 1。 示例 3:
输入: s = &amp;ldquo;pwwkew&amp;rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;ldquo;wke&amp;rdquo;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&amp;ldquo;pwke&amp;rdquo; 是一个子序列，不是子串。
提示：
0 &amp;lt;= s.length &amp;lt;= 5 * 104 s 由英文字母、数字、符号和空格组成
来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters
 解法一 public int lengthOfLongestSubstring(String s) {  Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();  int left = 0, right = 0;  int res = 0;  while (right &amp;lt; s.</description>
    </item>
    
    <item>
      <title>Leetcode438</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode438/</link>
      <pubDate>Sun, 22 May 2022 21:25:25 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode438/</guid>
      <description>438. 找到字符串中所有字母异位词  给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。
来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string
 public List&amp;lt;Integer&amp;gt; findAnagrams(String s, String p) {  List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();  if (p.length() &amp;gt; s.length()) {  return res;  }  int[] need = new int[26];  int[] window = new int[26];  int count = 0;  for (char c : p.toCharArray()) {  int index = getIndex(c);  if (need[index] == 0) {  count++;  }  need[index]++;  }  int left = 0, right = 0;  int valid = 0;  while (right &amp;lt; s.</description>
    </item>
    
    <item>
      <title>Leetcode567</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode567/</link>
      <pubDate>Sun, 22 May 2022 21:25:19 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode567/</guid>
      <description>567. 字符串的排列  给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。
换句话说，s1 的排列之一是 s2 的 子串 。
来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/permutation-in-string
 public boolean checkInclusion(String s1, String s2) {  if (s1.length() &amp;gt; s2.length()) {  return false;  }  // 初始化目标字符数组并计数  int[] need = new int[26];  int[] window = new int[26];  int count = 0;  for (char c : s1.toCharArray()) {  int index = getIndex(c);  if (need[index] == 0) {  count++;  }  need[index]++;  }   int left = 0, right = 0;  int valid = 0;  // 区间[left, right)  while (right &amp;lt; s2.</description>
    </item>
    
    <item>
      <title>Leetcode76</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode76/</link>
      <pubDate>Thu, 19 May 2022 22:54:36 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode76/</guid>
      <description>76. 最小覆盖子串  给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &amp;quot;&amp;quot; 。
注意：
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。
来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/minimum-window-substring
 解法一 public String minWindow(String s, String t) {  if (s.length() &amp;lt; t.length()) {  return &amp;#34;&amp;#34;;  }   // 初始化目标字符集合并计数  Map&amp;lt;Character, Integer&amp;gt; need = new HashMap&amp;lt;&amp;gt;();  for (int i = 0; i &amp;lt; t.length(); i++) {  need.</description>
    </item>
    
    <item>
      <title>Leetcode51</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode51/</link>
      <pubDate>Mon, 16 May 2022 22:50:57 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode51/</guid>
      <description>51. N 皇后  n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &amp;lsquo;Q&amp;rsquo; 和 &amp;lsquo;.&amp;rsquo; 分别代表了皇后和空位。
来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/n-queens
 public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueens(int n) {  List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();  char[][] temp = new char[n][n];  for (int i = 0; i &amp;lt; n; i++) {  for (int j = 0; j &amp;lt; n; j++) {  temp[i][j] = &amp;#39;.</description>
    </item>
    
    <item>
      <title>Leetcode322</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode322/</link>
      <pubDate>Mon, 09 May 2022 23:39:39 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode322/</guid>
      <description>322. 零钱兑换  给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/coin-change
 解法一，自顶向下
public int coinChange(int[] coins, int amount) {  int[] dp = new int[amount + 1];  // 初始化为无法达到的最大值  Arrays.fill(dp, amount + 1);  int res = coinChange(coins, amount, dp, amount);  // 判断是否能够凑整  return res != amount + 1 ? res : -1; }  private int coinChange(int[] coins, int amount, int[] dp, int total) {  if (amount == 0) {  return 0;  }  if (amount &amp;lt; 0) {  return -1;  }  // 利用记录结果减少重复计算  if (dp[amount] !</description>
    </item>
    
    <item>
      <title>Leetcode18</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode18/</link>
      <pubDate>Mon, 09 May 2022 22:28:29 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode18/</guid>
      <description>18. 四数之和  给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
0 &amp;lt;= a, b, c, d &amp;lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。
来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/4sum
 public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(int[] nums, int target) {  List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();  if (nums.length &amp;lt; 4) {  return res;  }  // 升序排序  Arrays.</description>
    </item>
    
    <item>
      <title>Leetcode509</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode509/</link>
      <pubDate>Sun, 08 May 2022 20:57:47 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode509/</guid>
      <description>509. 斐波那契数  斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &amp;gt; 1 给定 n ，请计算 F(n) 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fibonacci-number
 自底向上解法 public int fib(int n) {  // f(0)=0,f(1)=1  if (n &amp;lt;= 1) {  return n;  }  int a = 0;  int b = 1;  for (int i = 2; i &amp;lt;= n; i++) {  // 临时保存b的值，以便于赋值给a  int tmp = b;  b = a + b;  a = tmp;  }  return b; } 自顶向下解法 public int fib(int n) {  // 备忘录，记录已计算的函数值  int[] memo = new int[n + 1];  return helper(n, memo); }  private int helper(int n, int[] memo) {  if (n &amp;lt;= 1) {  return n;  }  // 如果备忘录已记录，则直接返回备忘录结果值  if (memo[n] !</description>
    </item>
    
    <item>
      <title>Leetcode15</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode15/</link>
      <pubDate>Fri, 06 May 2022 23:20:02 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode15/</guid>
      <description>15. 三数之和  给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum
 public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) {  List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();  if (nums.length &amp;lt; 3) {  return res;  }  // 排序后，遍历第一个数，并用双指针法计算后面两个数  Arrays.sort(nums);  for (int i = 0; i &amp;lt; nums.length - 2; i++) {  // 避免重复，跳过已经计算过的相同的第一个数  if (i !</description>
    </item>
    
    <item>
      <title>Leetcode1</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode1/</link>
      <pubDate>Fri, 06 May 2022 22:33:10 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode1/</guid>
      <description>1. 两数之和  给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum
 public int[] twoSum(int[] nums, int target) {  // 利用hash表提升检索效率  Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();  for (int i = 0; i &amp;lt; nums.length; i++) {  int other = target - nums[i];  // 遍历过程中判断后加入集合，效率最高  if (map.containsKey(other)) {  return new int[]{map.get(other), i};  }  map.put(nums[i], i);  }  return new int[]{-1, -1}; } </description>
    </item>
    
    <item>
      <title>Leetcode34</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode34/</link>
      <pubDate>Thu, 05 May 2022 23:13:58 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode34/</guid>
      <description>34. 在排序数组中查找元素的第一个和最后一个位置  给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array
 思路基于二分查找改造，边界条件判断可参考leetcode704。
解法一 public int[] searchRange(int[] nums, int target) {  int leftIndex = searchLeftRange(nums, target);  if (leftIndex == -1) {  return new int[]{-1, -1};  }   int rightIndex = searchRightRange(nums, target) ;  return new int[]{leftIndex, rightIndex}; }  private int searchLeftRange(int[] nums, int target) {  int left = 0;  int right = nums.</description>
    </item>
    
    <item>
      <title>Leetcode704</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode704/</link>
      <pubDate>Wed, 04 May 2022 22:30:12 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode704/</guid>
      <description>704. 二分查找  给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-search
 解法一 public int search(int[] nums, int target) {  // 区间[0, nums.length - 1]  int left = 0;  int right = nums.length - 1;  // 由于采用闭区间[0, nums.length - 1]，right初始为nums.length - 1，因此采用left&amp;lt;=right作为判断  while (left &amp;lt;= right) {  // 避免数字相加溢出  // 移位运算速度大于操作符  int mid = left + ((right - left) &amp;gt;&amp;gt; 1);  if (nums[mid] &amp;lt; target) {  // mid对应值小于目标值，缩小区间为[mid + 1, right]  left = mid + 1;  } else if (nums[mid] &amp;gt; target) {  // mid对应值大于目标值，缩小区间为[left, mid - 1]  right = mid - 1;  } else {  return mid;  }  }  return -1; } 解法二 public int search(int[] nums, int target) {  // 区间[0, nums.</description>
    </item>
    
    <item>
      <title>中断</title>
      <link>https://koudaihaizei.github.io/posts/java/concurrency/interrupts/</link>
      <pubDate>Tue, 26 Apr 2022 14:38:47 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/java/concurrency/interrupts/</guid>
      <description>中断用于指示线程停止正在做的事情，但线程响应中断的方式由程序决定，通常情况下程序会执行中断处理。
未对中断标识位判断，无法响应中断
/** * 无法中断 */ private void demo1() {  Thread thread = new Thread(() -&amp;gt; {  while (true) {  Thread.yield();  }  });  thread.start();  thread.interrupt(); } 程序通过对中断标识位判断做出处理，响应中断执行返回
/** * 响应中断 */ private void demo2() {  Thread thread = new Thread(() -&amp;gt; {  while (true) {  Thread.yield();  if (Thread.currentThread().isInterrupted()) {  System.out.println(&amp;#34;thread is interrupted&amp;#34;);  return;  }  }  });  thread.</description>
    </item>
    
    <item>
      <title>My 1st post</title>
      <link>https://koudaihaizei.github.io/page/</link>
      <pubDate>Tue, 15 Sep 2020 11:30:03 +0000</pubDate>
      
      <guid>https://koudaihaizei.github.io/page/</guid>
      <description>Desc Text.</description>
    </item>
    
  </channel>
</rss>
