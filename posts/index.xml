<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on JokerSite</title>
    <link>https://koudaihaizei.github.io/posts/</link>
    <description>Recent content in Posts on JokerSite</description>
    <image>
      <url>https://koudaihaizei.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://koudaihaizei.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 05 May 2022 23:13:58 +0800</lastBuildDate><atom:link href="https://koudaihaizei.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode34</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode34/</link>
      <pubDate>Thu, 05 May 2022 23:13:58 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode34/</guid>
      <description>34. 在排序数组中查找元素的第一个和最后一个位置  给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array
 思路基于二分查找改造，边界条件判断可参考leetcode704。
解法一 public int[] searchRange(int[] nums, int target) {  int leftIndex = searchLeftRange(nums, target);  if (leftIndex == -1) {  return new int[]{-1, -1};  }   int rightIndex = searchRightRange(nums, target) ;  return new int[]{leftIndex, rightIndex}; }  private int searchLeftRange(int[] nums, int target) {  int left = 0;  int right = nums.</description>
    </item>
    
    <item>
      <title>Leetcode704</title>
      <link>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode704/</link>
      <pubDate>Wed, 04 May 2022 22:30:12 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/algorithm/leetcode/leetcode704/</guid>
      <description>704. 二分查找  给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-search
 解法一 public int search(int[] nums, int target) {  // 区间[0, nums.length - 1]  int left = 0;  int right = nums.length - 1;  // 由于采用闭区间[0, nums.length - 1]，right初始为nums.length - 1，因此采用left&amp;lt;=right作为判断  while (left &amp;lt;= right) {  // 避免数字相加溢出  // 移位运算速度大于操作符  int mid = left + ((right - left) &amp;gt;&amp;gt; 1);  if (nums[mid] &amp;lt; target) {  // mid对应值小于目标值，缩小区间为[mid + 1, right]  left = mid + 1;  } else if (nums[mid] &amp;gt; target) {  // mid对应值大于目标值，缩小区间为[left, mid - 1]  right = mid - 1;  } else {  return mid;  }  }  return -1; } 解法二 public int search(int[] nums, int target) {  // 区间[0, nums.</description>
    </item>
    
    <item>
      <title>中断</title>
      <link>https://koudaihaizei.github.io/posts/java/concurrency/interrupts/</link>
      <pubDate>Tue, 26 Apr 2022 14:38:47 +0800</pubDate>
      
      <guid>https://koudaihaizei.github.io/posts/java/concurrency/interrupts/</guid>
      <description>中断用于指示线程停止正在做的事情，但线程响应中断的方式由程序决定，通常情况下程序会执行中断处理。
未对中断标识位判断，无法响应中断
/** * 无法中断 */ private void demo1() {  Thread thread = new Thread(() -&amp;gt; {  while (true) {  Thread.yield();  }  });  thread.start();  thread.interrupt(); } 程序通过对中断标识位判断做出处理，响应中断执行返回
/** * 响应中断 */ private void demo2() {  Thread thread = new Thread(() -&amp;gt; {  while (true) {  Thread.yield();  if (Thread.currentThread().isInterrupted()) {  System.out.println(&amp;#34;thread is interrupted&amp;#34;);  return;  }  }  });  thread.</description>
    </item>
    
  </channel>
</rss>
